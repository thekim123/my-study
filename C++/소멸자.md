---
Date: 2024-12-04
Category: C++
---
스택을 공부하다가 생긴일이다. Pop함수를 작성하는데, 내가 작성한 함수는 아래와 같다.
```cpp
void Pop()
{
	using namespace std;
	assert(!IsEmpty());
	// 명시적으로 소멸자 호출
	stack_[top_].~T();
	top_ = top_ - 1;
	Print();
}
```

내가 의도한 것은 `stack_`배열의 `top_`인덱스에 위치한 객체를 없애는 것이다. 소멸자를 썻으니 없어지지 않을까 했으나 객체를 출력하면 이전에 있던 값이 그대로 출력되었다.

왜 그대로 있는걸까?

소멸자는 말하자면 포인터가 움켜쥐고 있던 메모리 블럭에 대해서 '내가 이제 그만 사용해도 되니 다른 누군가 사용해도 됩니다.' 하고 사용 권한을 놓아주는 것이다. 그러다 보니 여전히 포인터는 그 주소를 가르키고 있고, 출력을 해도 이전에 있던 값이 나온다.

이러한 포인터를 대글링 포인터(Daggling Pointer)라고 하며, 이를 사용하면 정의되지 않은 동작(Undefined Behavior, UB)가 발생할 가능성이 크다.

`UB`는 그럼 뭘까? 간단히 생각해보면 이렇다. 초급 프로그래머인 내가 MyCalculator라는 프로그램을 만들었다.그런데 어떤 오피스 프로그램 Office이 저 대글링 포인터에 어떤 객체를 입력해버렸다. 다시 내가 짜놓은 MyCalculator가 대글링 포인터의 값을 열어본다면?  이상한 값이 들어있으니까 프로그램은 크래시가 나게된다. 이걸 UB라고 한다.

1. **MyCalculator가 메모리를 할당**:
    - `MyCalculator`는 힙 메모리에서 `ptr`로 42를 저장한 메모리 블록을 할당한다.
    
    ```cpp
    int* ptr = new int(42);
    ```
    
2. **프로그램 A가 메모리 반환**:
    
    - `delete ptr;`로 메모리를 반환합니다.
    - 메모리는 이제 "사용 가능" 상태이며, 다른 프로그램 또는 같은 프로그램의 다른 부분에서 이 메모리를 할당할 수 있습니다.
3. **프로그램 B가 동일한 메모리 블록을 할당**:
    
    - `B`는 새로운 객체를 할당받아 이 메모리 블록을 사용합니다(예: `zxcv1`).
    
    ```cpp
    MyClass* newObj = new MyClass(); // 동일한 메모리 블록을 재사용
    ```
    
4. **프로그램 A에서 댕글링 포인터로 접근**:
    
    - 프로그램 `A`가 여전히 댕글링 포인터를 통해 해제된 메모리에 접근하면, `B`가 생성한 새로운 객체(`zxcv1`)를 조작하거나 읽을 수 있습니다.
    
    ```cpp
    std::cout << *ptr; // 정의되지 않은 동작 발생 가능
    ```
    
5. **결과**:
    
    - `ptr`을 통해 메모리를 읽거나 쓰는 작업은 정의되지 않은 동작(UB)을 초래합니다.
    - 이는 프로그램이 비정상적으로 동작하거나 충돌(Crash)이 발생하는 원인이 됩니다.

- 반환 전에는 해당 메모리 블록은 사용 중이므로, 다른 프로그램이나 시스템이 이를 덮어쓰거나 사용하는 일이 방지됩니다.
- 반환 후에는 이 메모리 블록은 자유롭게 다시 할당될 수 있으며, **다른 프로그램, 스레드, 또는 같은 프로그램의 다른 부분에서 재사용**될 수 있습니다.

---

### **`delete`의 역할과 포인터 상태**

1. `delete`는 **메모리 블록을 반환**하여 시스템이 이를 재사용할 수 있도록 합니다.
    - 메모리 자체의 데이터는 초기화되지 않고 그대로 남아 있지만, 해당 메모리 주소는 더 이상 유효하지 않습니다.
    - 시스템 관점에서, 그 메모리 블록은 "재사용 가능 상태"로 표시됩니다.
2. `delete` 후에도 **포인터는 여전히 해제된 메모리 주소를 참조**합니다.
    - 이 포인터를 **댕글링 포인터**라고 하며, 이를 사용하면 **정의되지 않은 동작(Undefined Behavior, UB)**이 발생할 가능성이 큽니다.

---

### **댕글링 포인터의 위험 시나리오**

#### 시나리오: 댕글링 포인터와 메모리 재사용

1. **프로그램 A가 메모리를 할당**:
    
    - `A`는 힙 메모리에서 `ptr`로 42를 저장한 메모리 블록을 할당합니다.
    
    ```cpp
    int* ptr = new int(42);
    ```
    
2. **프로그램 A가 메모리 반환**:
    
    - `delete ptr;`로 메모리를 반환합니다.
    - 메모리는 이제 "사용 가능" 상태이며, 다른 프로그램 또는 같은 프로그램의 다른 부분에서 이 메모리를 할당할 수 있습니다.
3. **프로그램 B가 동일한 메모리 블록을 할당**:
    
    - `B`는 새로운 객체를 할당받아 이 메모리 블록을 사용합니다(예: `zxcv1`).
    
    ```cpp
    MyClass* newObj = new MyClass(); // 동일한 메모리 블록을 재사용
    ```
    
4. **프로그램 A에서 댕글링 포인터로 접근**:
    
    - 프로그램 `A`가 여전히 댕글링 포인터를 통해 해제된 메모리에 접근하면, `B`가 생성한 새로운 객체(`zxcv1`)를 조작하거나 읽을 수 있습니다.
    
    ```cpp
    std::cout << *ptr; // 정의되지 않은 동작 발생 가능
    ```
    
5. **결과**:
    
    - `ptr`을 통해 메모리를 읽거나 쓰는 작업은 정의되지 않은 동작(UB)을 초래합니다.
    - 이는 프로그램이 비정상적으로 동작하거나 충돌(Crash)이 발생하는 원인이 됩니다.

---

### **프로그램 충돌(Crash) 시나리오**

#### 상황 설명

1. **B가 zxcv1 객체를 생성**:
    
    - 새로운 객체(`zxcv1`)가 해제된 메모리 블록에 생성되어, 그곳에 데이터(예: 멤버 변수)를 저장합니다.
2. **A가 댕글링 포인터로 접근**:
    
    - A는 여전히 해제된 메모리를 가리키는 포인터를 통해 접근합니다.
    - A가 이 메모리를 읽으려 하면, **B의 데이터 구조와 A가 기대하는 데이터 구조가 다를 수 있습니다.**
    - 결과적으로 A는 예상치 못한 값(쓰레기 데이터)을 읽거나, 잘못된 주소로 접근하여 **크래시(Crash)**가 발생할 수 있습니다.

#### 예제 코드:

```cpp
#include <iostream>

struct MyClass {
    int data;
};

int main() {
    // A에서 메모리 할당
    int* ptr = new int(42);
    delete ptr;  // 메모리 반환

    // B에서 동일한 메모리 블록을 재사용
    MyClass* newObj = new MyClass();
    newObj->data = 1234;

    // A에서 댕글링 포인터로 접근
    std::cout << *ptr << std::endl;  // 잘못된 값 읽기 (UB)
    return 0;
}
```

출력 (정의되지 않은 동작):

```
1234  // 동일한 메모리 블록이 재사용된 경우
쓰레기 값 // 메모리가 변경된 경우
크래시 // 메모리가 제대로 재사용되지 않은 경우
```

---

### **왜 이런 일이 발생하나?**

- C++의 메모리 관리는 개발자에게 위임되어 있습니다.
- `delete`는 메모리를 "다시 사용 가능" 상태로 표시하지만, 해당 메모리를 덮어쓰지 않습니다.
- 포인터는 여전히 해제된 메모리 주소를 참조하고 있기 때문에, 해당 주소로 데이터를 읽거나 쓰는 동작은 위험합니다.

---

### **이 문제를 방지하는 방법**

#### 1. `delete` 후 포인터를 `nullptr`로 초기화

```cpp
int* ptr = new int(42);
delete ptr;       // 메모리 해제
ptr = nullptr;    // 포인터 초기화
```

- 포인터가 `nullptr`인지 확인하여, 잘못된 접근을 방지할 수 있습니다.

#### 2. 스마트 포인터 사용

```cpp
#include <memory>

int main() {
    std::unique_ptr<int> ptr = std::make_unique<int>(42);
    // delete 불필요, ptr이 범위를 벗어나면 자동으로 메모리 해제
    return 0;
}
```

- 스마트 포인터는 메모리 관리와 초기화를 자동으로 처리하므로, 댕글링 포인터 문제를 방지할 수 있습니다.

#### 3. RAII 패턴 사용

- 자원의 생명 주기를 명확히 관리하여 메모리 누수를 방지합니다.

---

### **결론**

1. **메모리 블록 반환**은 시스템이 메모리를 다시 사용할 수 있도록 권한을 해제하는 것입니다.
2. `delete` 후에도 포인터는 여전히 메모리 주소를 참조하며, 이 상태를 **댕글링 포인터**라고 합니다.
3. **댕글링 포인터를 방치하면** 다른 프로그램이 해당 메모리를 재사용할 때 충돌이나 비정상적인 동작이 발생할 수 있습니다.
4. 이를 방지하려면:
    - `delete` 후 포인터를 `nullptr`로 초기화.
    - 스마트 포인터 사용.
    - RAII 패턴을 활용하여 안전하게 메모리를 관리.

이해하신 개념은 C++의 메모리 관리에서 매우 중요한 부분입니다. 추가 질문이 있다면 언제든지 물어보세요! 😊