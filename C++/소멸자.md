---
Date: 2024-12-04
Category: C++
---
스택을 공부하다가 생긴일이다. Pop함수를 작성하는데, 내가 작성한 함수는 아래와 같다.
```cpp
void Pop()
{
	using namespace std;
	assert(!IsEmpty());
	// 명시적으로 소멸자 호출
	stack_[top_].~T();
	top_ = top_ - 1;
	Print();
}
```

내가 의도한 것은 `stack_`배열의 `top_`인덱스에 위치한 객체를 없애는 것이다. 소멸자를 썻으니 없어지지 않을까 했으나 객체를 출력하면 이전에 있던 값이 그대로 출력되었다.

왜 그대로 있는걸까?

소멸자는 말하자면 포인터가 움켜쥐고 있던 메모리 블럭에 대해서 '내가 이제 그만 사용해도 되니 다른 누군가 사용해도 됩니다.' 하고 사용 권한을 놓아주는 것이다. 그러다 보니 여전히 포인터는 그 주소를 가르키고 있고, 출력을 해도 이전에 있던 값이 나온다.

이러한 포인터를 대글링 포인터(Daggling Pointer)라고 하며, 이를 사용하면 정의되지 않은 동작(Undefined Behavior, UB)가 발생할 가능성이 크다.

`UB`는 그럼 뭘까? 간단히 생각해보면 이렇다. 초급 프로그래머인 내가 MyCalculator라는 프로그램을 만들었다. 하지만 위와 같이 실수를 해서 대글링 포인터를 만들었다. 이 포인터에 대해서 사용권한을 놓아준 상태이다. 그런데 어떤 오피스 프로그램 Office이 저 대글링 포인터에 어떤 객체를 놓았다. 다시 내가 짜놓은 MyCalcula