앞에서 공부한 `invokedynamic`을 공부하다가 흥미로운 생각이 들었다. 
```
내가 은행에서 일하는 개발자라면!!
람다식을 쓰는 함수를 알고 있으니,
jvm으로 접근해서 invokedynamic 명령어를 써서,
내 계좌잔고를 하루에 10만원 정도만 입금하도록 프로그램을 교묘하게 바꾸는거야!!
너무 많이하면 티나니까 딱 10만원만!!!!!!!
```

정리하는 시점에 와서는 이게 얼마나 터무니없는 생각인지는 알게 되었지만, 그래도 재미있는 상상이었고 많은 공부가 되었다.

일단 이걸 수행하려면 서버 pc의 ssh로 접근을 해야되는데 ssh를 접근할 수 있는 개발자라면 시스템에 굉장히 큰 권한을 가지고 있는 개발자이지 않을까 싶다. 그리고 jvm 메모리를 가져오려면 os단의 권한이 필요한데, 이 권한은 개발자여도 주지 않을 확률이 높다. 인프라 관리하는 사람이 따로 root 계정을 가지고 있고, 필요하면 내가 요청을 해야됬던 경우가 많았다.

무엇보다 이거 너무 고난이도다!! jvm에 대해 정말 깊이 잘 알아야되고, java 바이트코드와 jvm명령어를 직접 다룰 수 있어야 한다. 메모리 덤프를 가져오거나 클래스를 수정하고 이런것들은 서버에 로그가 남을 확률이 높다. 또한 agent를 삽입하는 것도... 삽입시점에 로그가 남을것이다.

아마도 이 공격은 오랜 시간동안 치밀하게 준비하고 많은 자원을 쏟아야 될거 같은데 내가 해커라면 아마 다른 공격을 시도할것같다.


일단 나는 뭔가 공격을 하는게 중요한게 아니라 내가 실행시켜놓은 springboot 데모 엔진에 jvm명령어를 사용해서 agent로 springboot 프로그램을 직접 제어가 가능한가? 이다. 



---
---
실습을 해보자. REST API로 노출된 Spring Boot 애플리케이션의 람다식 메서드를 **REST API를 사용하지 않고 JVM 명령어**로 직접 실행해보는 것은 일반적인 시도는 아니지만, JVM의 내부 동작과 메서드 호출 방식을 학습하기에 훌륭한 도전 과제입니다.

다음은 이 실습을 단계적으로 구현하는 방법입니다.

---

### **1. 간단한 Spring Boot 애플리케이션 구현**

먼저, **단순한 람다식 메서드를 제공하는 Spring Boot 애플리케이션**을 작성한다.

#### **애플리케이션 코드**

```java
package com.example.demo;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;
import java.util.function.BiFunction;

@RestController
public class CalculatorController {

    // 람다식 메서드
    private final BiFunction<Integer, Integer, Integer> add = (a, b) -> a + b;

    @GetMapping("/add")
    public Integer addNumbers(@RequestParam Integer a, @RequestParam Integer b) {
        return add.apply(a, b);
    }

    // Getter for the BiFunction (for reflection usage)
    public BiFunction<Integer, Integer, Integer> getAddFunction() {
        return add;
    }
}
```

#### **설명**

- **REST API 엔드포인트**: `/add`
    - 요청 예: `http://localhost:8080/add?a=5&b=3`
    - 응답: `8`
- **람다식 정의**: `BiFunction<Integer, Integer, Integer> add`
- **람다식 Getter**: `getAddFunction` 메서드로 람다식을 외부에서 접근 가능하도록 제공.

---

### **2. 애플리케이션 실행**

1. **Spring Boot 애플리케이션 실행**:
    
    ```bash
    ./mvnw spring-boot:run
    ```
    
2. **REST API 테스트**: 브라우저 또는 Postman으로 다음 URL 호출:
    
    ```
    http://localhost:8080/add?a=5&b=3
    ```
    
    결과: `8`

---

### **3. JVM 명령어로 메서드 실행**

#### **목표**

`REST API`가 아닌 **JVM 내부에서 직접 `add` 람다식을 호출**해보는 것이다.

---

### **4. Reflection을 사용해 JVM 내부에서 람다식 호출**

Spring Boot 애플리케이션의 JVM 내부에서 실행 중인 **`add` 람다식**을 호출하려면, 다음 단계를 따른다:

#### **Reflection 코드 작성**
Reflection을 통해 Spring Boot 애플리케이션의 특정 인스턴스를 가져오고, 람다식 메서드를 호출한다.

#### **Reflection 실행 코드**
다음 코드를 작성하여 JVM 내부에서 `add` 메서드를 직접 호출한다.

```java
import java.lang.reflect.Method;
import java.util.function.BiFunction;

public class InvokeLambda {
    public static void main(String[] args) throws Exception {
        // 1. Spring Boot 애플리케이션 클래스 로드
        Class<?> controllerClass = Class.forName("com.example.demo.CalculatorController");

        // 2. 인스턴스 생성 (Spring Boot 컨트롤러가 실제 객체 생성했다고 가정)
        Object controllerInstance = controllerClass.getDeclaredConstructor().newInstance();

        // 3. 람다식 메서드(getAddFunction) 호출
        Method getAddFunctionMethod = controllerClass.getMethod("getAddFunction");
        BiFunction<Integer, Integer, Integer> addFunction =
                (BiFunction<Integer, Integer, Integer>) getAddFunctionMethod.invoke(controllerInstance);

        // 4. 람다식 호출
        int result = addFunction.apply(10, 20);
        System.out.println("Result from lambda: " + result); // 30
    }
}
```

#### **코드 설명**

1. **Reflection으로 클래스 로드**:
    - `Class.forName("com.example.demo.CalculatorController")`를 사용하여 Spring 컨트롤러 클래스 로드.
2. **컨트롤러 인스턴스 생성**:
    - Reflection을 사용해 `CalculatorController` 인스턴스 생성.
3. **람다식 가져오기**:
    - `getAddFunction` 메서드를 호출해 람다식(`BiFunction`) 참조를 가져옴.
4. **람다식 직접 호출**:
    - `addFunction.apply(10, 20)`로 직접 실행.

#### **실행 방법**

1. Reflection 코드를 별도 프로젝트로 작성하거나 Spring Boot 애플리케이션의 테스트 코드로 포함.
2. Reflection 코드를 실행하여 결과 확인:
    
    ```bash
    java InvokeLambda
    ```
    
---

### **6. 결과**

Reflection 코드를 실행하면 JVM 내부에서 Spring Boot 컨트롤러의 람다식을 직접 호출하고, 결과를 출력할 수 있다.

#### 실행 결과:

```plaintext
Result from lambda: 30
```

이걸로 로그를 찍으면 스프링에 찍히는 것은 아니고, 그냥 내가 따로 실행한 프로그램에 찍힌다. 그래서 원격으로 실행할 수 있는 방법으로 다시 도전해봤다.

---


---
---
