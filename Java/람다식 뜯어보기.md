
## 1. 람다식을 쓰고 컴파일해보자.

람다식이나 메서드 참조는 인텔리제이가 변환해줘서 많이 써왔고 어떤식으로 동작하는지 대충 알지만, 정확히 이게 어떤식으로 작동하는지 내부에서는 어떤식으로 이걸 움직이는지 몰랐다. 그래서 공부해봤다.

예전에 썻던 그 예제 그대로 써봤다.
```java
public class Main {  
    public Main() {  
    }  
    public static int add(int a, int b) {  
        return a + b;  
    }  
  
    public static void main(String[] args) {  
        BiFunction<Integer, Integer, Integer> add = Main::add;  
        System.out.println(add.apply(1, 2));  
        BiFunction<Integer, Integer, Integer> multi = (a, b) -> a * b;  
        System.out.println(multi.apply(1, 2));  
    }  
  
    public static void performOperation(int a, int b, BiFunction<Integer, Integer, Integer> operation) {  
        System.out.println(operation.apply(a, b));  
    }  
}
```
일단 `::` 이나 `->` 모두 어떤건지 보면 `BiFunction` 이것임을 알 수 있었다. 그럼 정확하게 얘는 어떤식으로 작동할까

아래는 javap를 사용하여 위의 코드를 디스어셈블한 것이다. 
```java
  public static void main(java.lang.String[]);
    Code:
       0: invokedynamic #7,  0              // InvokeDynamic #0:apply:()Ljava/util/function/BiFunction;
       5: astore_1
       6: getstatic     #11                 // Field java/lang/System.out:Ljava/io/PrintStream;
       9: aload_1
      10: iconst_1
      11: invokestatic  #17                 // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;
		...
```
`0: invokedynamic`에 주목하자. 이 바이트코드가 람다식에 해당하는 바이트코드이다.  `invokedynamic` 명령어는 런타임에 메서드 핸들을 동적으로 바인딩한다. 람다식은 이 명령어를 통해 `java.lang.invoke.LambdaMetafactory`에서 생성된 **메서드 핸들**로 연결된다.


---
## 2. 람다식과 익명클래스의 차이

흔히 강의를 듣거나 하다보면 익명클래스 = 람다식이라고 생각하라는 말을 많이 들어왔다. 쓰임새도 비슷하고 하니 그동안 그렇게 생각했다. 그런데 이번에 공부하면서 둘은 꽤 많이 다름을 알게 되었다.

```java
// 익명 클래스 
Function<Integer, Integer> squareWithAnonymousClass = new Function<>() {   
	@Override     
	public Integer apply(Integer x) {
         return x * x;
	    }
    };
```

익명 클래스를 쓰면 클래스 파일이 하나 생긴다. ClassName$1.class 이런식으로. 그런데 둘이 같은거면 람다식을 쓸 때도 클래스가 생겨야 하지 않을까? 그런데 안생긴다. 둘의 차이점에 대한 표가 아래에 있다.
### 1) **람다식과 익명 클래스의 차이**

|**특징**|**익명 클래스**|**람다식**|
|---|---|---|
|**구현 방식**|컴파일 시 별도의 `.class` 파일(익명 클래스)이 생성됨|`invokedynamic` 명령어를 사용해 런타임에 메서드 핸들로 생성|
|**메모리 사용**|별도의 클래스 로딩과 인스턴스 생성 비용이 발생|메서드 핸들로 처리되므로 메모리 사용량이 적음|
|**동작 방식**|익명 클래스의 객체를 생성해 실행|`LambdaMetafactory`가 최적화된 바이트코드를 생성|
|**사용 용도**|인터페이스 구현뿐 아니라 상속을 통해 다양한 기능 가능|함수형 인터페이스와 함께 사용하여 함수형 프로그래밍에 적합|
|**`this` 키워드**|익명 클래스 내부에서 익명 클래스 인스턴스를 참조|람다식 내부에서 외부의 `this`를 참조|

### 2) **람다식이 익명 클래스와 다른 이유**

1. **`invokedynamic` 기반**
    - 람다식은 익명 클래스처럼 추가적인 `.class` 파일을 생성하지 않는다.
    - JVM의 `invokedynamic` 명령어와 `LambdaMetafactory`를 통해 런타임에 동적으로 메서드 핸들을 생성한다.

2. **클래스 상속과 차이점**
    - 익명 클래스는 **상속**을 통해 부모 클래스나 인터페이스를 구현하는 데 사용된다.
    - 람다식은 **함수형 인터페이스(단일 추상 메서드 인터페이스)**만을 대상으로 동작합니다.

3. **`this` 키워드 동작**
    - 익명 클래스 내부의 `this`는 익명 클래스 자체를 가리킨다.
    - 람다식 내부의 `this`는 람다식을 포함하는 **외부 클래스**를 가리킨다.

### 3) **정리**

람다식이 익명 클래스의 단순한 요약이라고 말하는 것은 **람다식의 본질을 축소하는 표현**이다.

- 익명 클래스는 **객체 지향적인 클래스 인스턴스 생성** 방식이고,
- 람다식은 **함수형 프로그래밍**을 Java에 구현하기 위한 새로운 동작 방식입니다.

람다식은 **동작의 표현을 간소화**하면서도 성능 최적화와 유연성을 제공하기 위해 만들어졌으며, 익명 클래스를 대체하기보다는 **함수형 인터페이스를 활용하기 위한 새로운 도구**로 설계되었다.

---

## 3. 