람다식이나 메서드 참조는 인텔리제이가 변환해줘서 많이 써왔고 어떤식으로 동작하는지 대충 알지만, 정확히 이게 어떤식으로 작동하는지 내부에서는 어떤식으로 이걸 움직이는지 몰랐다. 그래서 공부해봤다.

예전에 썻던 그 예제 그대로 써봤다.
```java
public class Main {  
    public Main() {  
    }  
    public static int add(int a, int b) {  
        return a + b;  
    }  
  
    public static void main(String[] args) {  
        BiFunction<Integer, Integer, Integer> add = Main::add;  
        System.out.println(add.apply(1, 2));  
        BiFunction<Integer, Integer, Integer> multi = (a, b) -> a * b;  
        System.out.println(multi.apply(1, 2));  
    }  
  
    public static void performOperation(int a, int b, BiFunction<Integer, Integer, Integer> operation) {  
        System.out.println(operation.apply(a, b));  
    }  
}
```
일단 `::` 이나 `->` 모두 어떤건지 보면 `BiFunction` 이것임을 알 수 있었다. 그럼 정확하게 얘는 어떤식으로 작동할까

아래는 javap를 사용하여 위의 코드를 디스어셈블한 것이다. 각 코드 섹션을 살펴보며 **무엇을 하는지 분석**해보자.
```java

public class Main {  
  
  public Main();
    Code:
       0: aload_0 
       1: invokespecial #1                  // Method java/lang/Object."<init>":()V
       4: return

  public static int add(int, int);
    Code:
       0: iload_0
       1: iload_1
       2: iadd
       3: ireturn

  public static void main(java.lang.String[]);
    Code:
       0: invokedynamic #7,  0              // InvokeDynamic #0:apply:()Ljava/util/function/BiFunction;
       5: astore_1
       6: getstatic     #11                 // Field java/lang/System.out:Ljava/io/PrintStream;
       9: aload_1
      10: iconst_1
      11: invokestatic  #17                 // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;
      14: iconst_2
      15: invokestatic  #17                 // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;
      18: invokeinterface #23,  3           // InterfaceMethod java/util/function/BiFunction.apply:(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
      23: invokevirtual #28                 // Method java/io/PrintStream.println:(Ljava/lang/Object;)V
      26: invokedynamic #34,  0             // InvokeDynamic #1:apply:()Ljava/util/function/BiFunction;
      31: astore_2
      32: getstatic     #11                 // Field java/lang/System.out:Ljava/io/PrintStream;
      35: aload_2
      36: iconst_1
      37: invokestatic  #17                 // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;
      40: iconst_2
      41: invokestatic  #17                 // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;
      44: invokeinterface #23,  3           // InterfaceMethod java/util/function/BiFunction.apply:(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
      49: invokevirtual #28                 // Method java/io/PrintStream.println:(Ljava/lang/Object;)V
      52: return

  public static void performOperation(int, int, java.util.function.BiFunction<java.lang.Integer, java.lang.Integer, java.lang.Integer>);
    Code:
       0: getstatic     #11                 // Field java/lang/System.out:Ljava/io/PrintStream;
       3: aload_2
       4: iload_0
       5: invokestatic  #17                 // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;
       8: iload_1
       9: invokestatic  #17                 // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;
      12: invokeinterface #23,  3           // InterfaceMethod java/util/function/BiFunction.apply:(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
      17: invokevirtual #28                 // Method java/io/PrintStream.println:(Ljava/lang/Object;)V
      20: return
}

```



---

## **코드 구조**

바이트코드는 Java 클래스의 메서드와 필드를 설명하며, 각각은 JVM 명령어로 표현됩니다. 이 코드는 `Main` 클래스의 디스어셈블 결과로 보입니다.

### **1. 클래스 선언**

```java
public class Main {
```

- 클래스 이름이 `Main`이며, `public`으로 선언되었다.

---

### **2. 기본 생성자**

```java
  public Main();
    Code:
       0: aload_0
       1: invokespecial #1                  // Method java/lang/Object."<init>":()V
       4: return
```

- **기본 생성자**가 컴파일러에 의해 자동 생성되었다.
- 명령어 설명:
    1. `aload_0`: 로컬 변수 0(현재 객체, `this`)를 스택에 로드.
    2. `invokespecial`: 부모 클래스(`Object`)의 생성자를 호출. 여기서 `java/lang/Object.<init>`를 호출.
    3. `return`: 메서드 종료.

결론: `Main` 클래스는 기본 생성자를 호출하면 부모 클래스의 생성자만 실행하고 종료된다.

---

### **3. 정적 메서드 `add`**

```java
  public static int add(int, int);
    Code:
       0: iload_0
       1: iload_1
       2: iadd
       3: ireturn
```

- **정적 메서드 `add`**: 두 개의 정수(`int`)를 더한 결과를 반환합니다.
- 명령어 설명:
    1. `iload_0`: 첫 번째 매개변수(스택에서 `int`)를 로드.
    2. `iload_1`: 두 번째 매개변수를 로드.
    3. `iadd`: 두 값을 더함.
    4. `ireturn`: 결과를 반환.

결론: `add(int, int)`는 두 정수를 더하고 반환하는 간단한 메서드이다.

---

### **4. `main` 메서드**

```java
  public static void main(java.lang.String[]);
```

- **`main` 메서드**는 프로그램 실행의 진입점이다.

#### 주요 동작

1. **첫 번째 람다식 생성**
    
    ```java
    0: invokedynamic #7,  0              // InvokeDynamic #0:apply:()Ljava/util/function/BiFunction;
    5: astore_1
    ```
    
    - `invokedynamic`: 런타임에 `LambdaMetafactory`를 사용하여 `BiFunction` 구현체를 생성.
    - 생성된 람다식을 변수 `astore_1`에 저장.
2. **람다식 실행**
    
    ```java
    6: getstatic     #11                 // Field java/lang/System.out:Ljava/io/PrintStream;
    9: aload_1
    10: iconst_1 11: invokestatic #17 // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer; 14: iconst_2 15: invokestatic #17 // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer; 18: invokeinterface #23, 3 // InterfaceMethod java/util/function/BiFunction.apply:(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object; 23: invokevirtual #28 // Method java/io/PrintStream.println:(Ljava/lang/Object;)V
```

- **동작 요약**:
  - `System.out.println`에 람다식 결과 출력.
  - `BiFunction.apply` 메서드를 호출하여 두 값을 더한 결과를 얻음.
  - 출력: `3`.

3. **두 번째 람다식 생성 및 실행**
```java
26: invokedynamic #34,  0             // InvokeDynamic #1:apply:()Ljava/util/function/BiFunction;
```

- 첫 번째와 유사하게 `invokedynamic`을 통해 새로운 `BiFunction` 구현체 생성.
- 같은 방식으로 실행 및 출력.

---

### **5. `performOperation` 메서드**

```plaintext
  public static void performOperation(int, int, java.util.function.BiFunction<java.lang.Integer, java.lang.Integer, java.lang.Integer>);
```

- 이 메서드는 정수 두 개와 `BiFunction`을 받아 동작을 수행합니다.

#### 주요 동작

1. **`System.out.println` 사용**
    
    ```plaintext
    0: getstatic     #11                 // Field java/lang/System.out:Ljava/io/PrintStream;
    ```
    
    - `System.out` 객체를 가져옴.
2. **`BiFunction.apply` 호출**
    
    ```plaintext
    3: aload_2
    4: iload_0
    5: invokestatic  #17                 // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;
    8: iload_1
    9: invokestatic  #17                 // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;
    ```
    

12: invokeinterface #23, 3 // InterfaceMethod java/util/function/BiFunction.apply:(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;

````
- `BiFunction.apply`를 호출하여 두 정수의 결과를 계산.

3. **결과 출력**
```plaintext
17: invokevirtual #28                 // Method java/io/PrintStream.println:(Ljava/lang/Object;)V
20: return
````

- 계산된 결과를 `System.out.println`으로 출력.

---

### **`invokedynamic`의 역할**

- `invokedynamic`은 람다식 구현체를 동적으로 생성합니다.
- 이 바이트코드는 `LambdaMetafactory`에서 생성된 `BiFunction` 객체를 사용해 두 정수를 처리하고 출력합니다.

---

### **요약**

1. **생성자**:
    
    - `Main` 클래스의 기본 생성자는 부모 클래스(`Object`) 생성자를 호출.
2. **`add` 메서드**:
    
    - 두 정수를 더하는 간단한 정적 메서드.
3. **`main` 메서드**:
    
    - 두 개의 람다식을 생성(`invokedynamic`)하고 실행하여 결과를 출력.
4. **`performOperation` 메서드**:
    
    - 두 정수와 `BiFunction`을 받아 계산 결과를 출력.

이 코드는 람다식(`invokedynamic`)의 처리 과정을 보여주는 전형적인 예제입니다. 바이트코드를 통해 람다식이 동적으로 생성되고, `BiFunction` 인터페이스를 통해 실행되는 과정을 확인할 수 있습니다.