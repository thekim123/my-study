---
Date: 2024-12-12
Category:
---
## 1. Size() 구현 
size함수를 처음 구현할 때는 좀 더 지저분하게 구현했지만 두 세번쯤 하다보니 아래와 같이 하게 되었다.
```cpp
int Size() const
{

	int size = 0;
	int indexDiffernce = rear_ - front_;
	if (indexDiffernce >= 0)
	{
		size = indexDiffernce;
	}
	else {
		size = capacity_ - indexDiffernce;
	}
	return size;
}
```

문득 나머지를 활용하면 저 둘을 합칠 수 있지 않을까? 하고 생각했다.
그래서 생각해낸 코드가 이것이다.
```cpp
	int Size() const
	{
		int size = 0;
		int indexDiffernce = rear_ - front_;
		size = capacity_ - (capacity_ - indexDiffernce) % capacity_;
		return size;
	}
```

이것은 근데 `indexDifference=0`일 때 `capacity_`를 반환하는 문제가 있다. 그럼 결국 3항연산자나  if문을 넣어서 분기하는 방법이 끝인걸까? 하는 생각이 들어 gpt한테 물어보니 gpt는 그것이 최선이다 라고 말하면서 나의 수식을 아래와 같이 정리해주었다.
```cpp
size = (capacity_ + indexDifference) % capacity_;
```

이 수식을 보면서 혹시 나누기 연산에도 교환법칙같은 것이 존재하는지 궁금했고, 이것에 대해서 물어봤다. 

나머지 연산(`%`)은 덧셈과 뺄셈에 대해 **일정 부분 교환 법칙**이 성립한다. 그러나 곱셈이나 나눗셈처럼 완전한 교환 법칙이 적용되지는 않는다. 나머지 연산의 특성을 이해하면 아래와 같이 정리할 수 있다.

---

### 1. **덧셈/뺄셈에서 나머지 연산의 교환 성질**

- `(a + b) % c == ((a % c) + (b % c)) % c`
- `(a - b) % c == ((a % c) - (b % c) + c) % c` _(음수 처리 필요)_

위 성질은, 나머지 연산이 값들을 "랩핑(wrapping)"하는 방식 때문이다. 덧셈과 뺄셈은 나머지 연산 안에서 성립되며, 결과를 다시 `mod`로 계산하면 동일한 결과를 얻는다.

---
