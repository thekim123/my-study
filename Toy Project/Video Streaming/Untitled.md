---
Date: 2024-12-30
Category: Toy Project
---
### 🎯 **백엔드 설계 방향: 비식별화된 영상 데이터 처리**
---

## 📚 **1. 프레임 단위 vs 영상 파일 단위**

### ✅ **1.1 프레임 단위로 제공**

- **설명:** 영상을 프레임 단위로 분할한 후, 각 프레임을 비식별화(모자이크) 처리하여 프론트에 제공
- **장점:**
    - 프론트에서 단계적으로 프레임을 로드하여 점진적으로 영상을 렌더링할 수 있음
    - 실시간으로 처리된 프레임을 전달 가능
- **단점:**
    - 프레임 단위로 쪼개고 처리하는 오버헤드 발생
    - 프론트에서 프레임을 조합하여 다시 영상으로 만드는 로직 필요

**📌 추천 상황:**

- 실시간 스트리밍이나 단계적으로 데이터를 처리해야 할 경우

---
## 🛠️ **1. 전체 흐름**

1. **영상 업로드 → 프레임 생성**
    
    - 백엔드에서 영상을 프레임 단위로 분할하여 저장
    - 각 프레임에 기본적인 모자이크 적용
2. **프레임 전송 → 사용자 보정**
    
    - 프론트엔드는 각 프레임을 사용자에게 제공
    - 사용자는 프레임 단위로 모자이크 추가/제거 보정을 수행
3. **보정된 프레임 저장**
    
    - 사용자가 수정한 프레임을 백엔드에 다시 전송
    - 백엔드는 수정된 프레임을 저장
4. **최종 영상 생성**
    
    - 백엔드에서 모든 프레임을 합쳐 최종 영상을 생성
5. **최종 영상 반환**
    
    - 최종 영상 파일을 사용자에게 제공

---
## 🚀 **2. 네트워크 병목 문제: 프레임 전송 최적화**

네트워크로 **영상 전체를 프레임 단위로 나눠 주고받는 구조**는 확실히 데이터 전송량이 매우 커지고 병목이 발생할 수 있어. 이를 해결하기 위해 **다양한 최적화 전략**을 사용할 수 있어.

---

### 🛠️ **1) 네트워크 병목 문제의 원인**

1. **프레임 개수 증가**
    - 1초에 30fps인 영상의 경우, 10초만 해도 300개의 프레임이 생성됨.
2. **프레임 용량**
    - 각 프레임은 고해상도 이미지일 수 있어.
3. **다중 사용자 환경**
    - 여러 사용자가 동시에 영상을 업로드 및 보정하면 서버와 네트워크 부하가 급증.

### 📚 **2) 최적화 전략**
#### ✅ **2.1 스트리밍 방식 사용 (WebSocket or HTTP Range Requests)**

- **설명:** 모든 프레임을 한 번에 전송하는 대신, 필요한 프레임만 스트리밍 방식으로 전송
- **예시:**
    - 사용자가 스크롤하거나 특정 프레임을 선택할 때만 해당 프레임을 전송
- **장점:** 실시간으로 필요한 데이터만 주고받음
- **단점:** 구현 복잡성 증가
---
#### ✅ **2.2 압축 사용 (Image Compression & Video Encoding)**

- **설명:** 프레임을 고해상도 이미지로 보내는 대신 **JPEG, WebP 등으로 압축**
- **예시:**
    - PNG 대신 WebP 사용 (최대 30-40% 용량 절감)
    - 프레임 묶음을 작은 동영상으로 인코딩
- **장점:** 데이터 전송량 절감
- **단점:** 인코딩 및 디코딩 시 약간의 CPU 오버헤드
---
---

## 🧩 **3. 아키텍처 설계**
---
### 🧠 **1) 영상/이미지 저장 및 관리 아키텍처 설계**

**Spring Boot와 Python 엔진 간의 데이터 흐름 및 저장 전략**은 전체 시스템의 성능, 확장성, 유지보수성에 큰 영향을 미칩니다. 각각의 방식에 대한 장단점을 분석하고 최적의 설계를 찾아보겠습니다.

---
### 🚦 **2) 저장 전략: 4가지 접근 방식**

#### ✅ **1-1 Python이 직접 저장 (공유 DB 접근)**

- **설명:** Python 엔진이 직접 데이터베이스(DB)에 접근하여 프레임 이미지 및 메타데이터를 저장.
- **흐름:**
    1. Spring Boot → Python으로 영상 전달
    2. Python 엔진: 프레임 분할 및 비식별화 처리
    3. Python 엔진 → DB에 프레임 저장
    4. Spring Boot → DB를 조회하여 사용자에게 프레임 정보 전달

✅ **장점:**
- Spring Boot와 Python 간의 데이터 교환 오버헤드 없음
- Python이 DB에 직접 저장하므로 효율적

❌ **단점:**
- **공유 DB 문제:** Spring Boot와 Python 엔진이 같은 DB 스키마를 공유
- Python 엔진에 DB 접근 권한이 필요함 (보안 문제 발생 가능)
- DB 스키마 변경 시 두 시스템 모두 수정 필요 (결합도가 높아짐)

**📌 결론:** 일반적으로 권장되지 않는 방법. 두 시스템이 하나의 DB를 직접 공유하는 것은 **결합도를 높이고 유지보수를 어렵게 만듦**.

---
#### ✅ **1-2 Python이 처리 후 Spring Boot로 반환 → Spring Boot가 저장**
- **설명:** Python 엔진은 프레임을 생성하고 비식별 처리한 후, 결과물을 Spring Boot에 반환.
- **흐름:**
    1. Spring Boot → Python으로 영상 전달
    2. Python 엔진: 프레임 분할 및 비식별화 처리
    3. Python 엔진 → 비식별화된 프레임을 Spring Boot로 반환 (파일 경로 or 데이터 스트림)
    4. Spring Boot → DB에 메타데이터 저장
    5. 
✅ **장점:**
- Python 엔진이 DB에 접근할 필요가 없음
- 데이터베이스 접근 권한 및 보안 문제 해결
- Spring Boot가 일관된 데이터 접근 및 관리 수행

❌ **단점:**
- Python → Spring Boot로 프레임 데이터를 전송하는 과정에서 **네트워크 오버헤드** 발생
- 대용량 프레임을 전송할 경우, Spring Boot WAS에 부하 발생

**📌 결론:** 네트워크 오버헤드가 걱정되긴 하지만, **책임 분리가 명확하고 보안상 안전**하기 때문에 이 방식이 **더 권장됨**.

---
#### ✅ **1-4 Python이 처리 후 스토리지에 저장 → Spring Boot가 메타데이터 관리**

- **설명:** Python 엔진이 프레임 데이터를 **오브젝트 스토리지 (e.g., AWS S3, MinIO, NAS)**에 저장하고, Spring Boot는 해당 스토리지의 메타데이터만 관리.
- **흐름:**
    1. Spring Boot → Python으로 영상 전달
    2. Python 엔진: 프레임 분할 및 비식별화 처리
    3. Python 엔진 → 스토리지에 프레임 저장 (경로 반환)
    4. Python 엔진 → Spring Boot에 메타데이터(경로, 프레임 ID) 전달
    5. Spring Boot → DB에 메타데이터 저장

✅ **장점:**

- Python 엔진과 Spring Boot 간 데이터 전송 오버헤드 최소화
- Python 엔진이 직접 스토리지에 접근하므로 대량의 데이터 전송 문제 해결
- Spring Boot는 메타데이터만 관리하므로 WAS 부하 감소

❌ **단점:**

- Python 엔진과 Spring Boot 간 스토리지 접근 권한 설정 필요
- 추가적인 스토리지 비용 발생 가능

**📌 결론:** **현대적인 클라우드 아키텍처에서 가장 많이 사용되는 방식**. 데이터 처리와 메타데이터 관리가 분리되어 효율적임.

---

### 🚀 **Kafka를 활용한 영상/이미지 처리 아키텍처**

Kafka는 **분산 스트리밍 플랫폼**으로 대규모 데이터의 **실시간 처리와 비동기 통신**에 매우 적합해. 특히 영상/이미지 데이터를 **Spring Boot ↔ Python 엔진 간에 중간 버퍼 역할**로 사용할 수 있어.

---
## 🛠️ **2. Kafka 기반 설계 아키텍처**

## 📊 **1. Kafka 아키텍처의 주요 강점**

### ✅ **1.1 성능 (Performance)**

- **비동기 처리:** Spring Boot와 Python 엔진이 **동기적으로 데이터를 주고받지 않아도 됨**.
- **네트워크 오버헤드 최소화:** 데이터는 Kafka Broker를 통해 한 번만 전송되고, 필요할 때 소비됨.
- **데이터 흐름 최적화:** Python 엔진이 처리 가능한 양만큼만 데이터를 수신함.

### ✅ **1.2 확장성 (Scalability)**

- **Python 엔진 확장:** Python 엔진을 여러 대로 수평 확장 가능.
- **Spring Boot 확장:** Spring Boot도 여러 인스턴스로 확장 가능.
- **Kafka의 파티션(Partition):** 데이터가 여러 파티션으로 나뉘어 병렬 처리 가능.

### ✅ **1.3 책임 분리 (Separation of Concerns)**

- **Spring Boot:** API 관리, 메타데이터 관리, 사용자 요청 처리.
- **Kafka:** 데이터 중계 및 버퍼링 역할.
- **Python 엔진:** 영상 프레임 분할 및 비식별화.

### ✅ **1.4 안정성 및 내결함성 (Fault Tolerance)**

- **데이터 손실 방지:** Kafka는 데이터 손실 없이 브로커에 안전하게 저장.
- **에러 격리:** Python 엔진이나 Spring Boot 중 하나가 실패해도 전체 시스템이 멈추지 않음.

### ✅ **1.5 실시간 데이터 처리**

- **실시간 프레임 전송 및 처리:** 영상 프레임이 Python 엔진으로 즉시 전달되어 처리됨.
- **프론트엔드 실시간 업데이트:** Spring Boot가 처리된 메타데이터를 실시간으로 프론트엔드에 제공 가능.
---
## 📊 **5. Kafka 활용의 장점**

✅ **Spring Boot와 Python 엔진 간 강한 결합도 제거**  
✅ **비동기 처리로 효율성 극대화**  
✅ **장애 격리:** Python 엔진에 문제가 발생해도 Spring Boot가 영향받지 않음  
✅ **확장성:** Python 엔진이나 Spring Boot를 독립적으로 확장 가능

❌ **단점:**

- Kafka 인프라 운영 및 모니터링 필요
- 추가적인 Kafka 메시지 설계 및 관리 필요
---
Kafka를 추가함으로써:
- **결합도를 낮추고 확장성을 극대화**
- **영상 처리 병목 현상 해소**
- **대용량 데이터의 실시간 스트리밍 지원**

## 📚 **1. 네 가지 아키텍처 요약**

| **구분**                                          | **설명**                                    | **장점**                      | **단점**                             | **적합한 상황**                 |
| ----------------------------------------------- | ----------------------------------------- | --------------------------- | ---------------------------------- | -------------------------- |
| **1. Python이 DB 직접 접근**                         | Python이 영상 처리 후 DB에 직접 저장                 | 네트워크 오버헤드 없음단일 단계 데이터 저장    | 두 시스템이 DB를 공유 (결합도 높음)보안 이슈        | 매우 단순한 구조로 빠르게 개발해야 할 때    |
| **2. Python → Spring Boot로 반환**                 | Python이 처리한 결과를 Spring Boot로 전달해 저장       | 책임 분리가 명확보안 이슈 없음           | 네트워크 오버헤드 발생Spring Boot WAS 부하     | 작은 규모의 프로젝트 또는 데이터 양이 적을 때 |
| **3. Python → 스토리지 저장 → Spring Boot가 메타데이터 관리** | Python이 스토리지에 저장, 메타데이터는 Spring Boot에서 관리 | 네트워크 오버헤드 최소화책임 분리 명확확장성 우수 | 스토리지 추가 비용 발생스토리지 권한 설정 필요         | 대규모 데이터, 확장성이 필요한 경우       |
| **4. Kafka를 통한 비동기 처리**                         | Kafka를 통해 Python과 Spring Boot가 비동기 처리     | 완전한 비동기 구조높은 확장성병목 현상 최소화   | Kafka 인프라 운영 필요. 복잡한 메시징 시스템 관리 필요 | 대규모 트래픽, 실시간 처리 요구가 있을 때   |

---
## 🛠️ **2. 아키텍처 평가 기준**

1. **성능 (Performance)**
    
    - 네트워크 및 시스템 오버헤드 최소화
    - 대량의 영상/프레임을 처리할 수 있는 효율성
2. **확장성 (Scalability)**
    
    - Python 엔진과 Spring Boot를 독립적으로 확장 가능해야 함
3. **책임 분리 (Separation of Concerns)**
    
    - 각 시스템이 명확한 역할을 수행해야 함
4. **유지보수 (Maintainability)**
    
    - 시스템 변경 및 관리가 용이해야 함
5. **보안 (Security)**
    
    - 데이터베이스 접근 권한, 스토리지 권한이 안전해야 함
---
## 📊 **3. 평가 테이블**

|**기준**|**1. Python이 DB 직접 접근**|**2. Python → Spring Boot 반환**|**3. Python → 스토리지 저장**|**4. Kafka 비동기 처리**|
|---|---|---|---|---|
|**성능**|🟡 중간|🟡 중간|🟢 우수|🟢 우수|
|**확장성**|🔴 낮음|🟡 중간|🟢 우수|🟢 매우 우수|
|**책임 분리**|🔴 불명확|🟢 명확|🟢 명확|🟢 매우 명확|
|**유지보수**|🔴 어려움|🟡 중간|🟢 용이|🔴 어려움 (Kafka 관리)|
|**보안**|🔴 위험|🟢 안전|🟢 안전|🟢 안전|
|**적합한 규모**|소규모|중소규모|중대규모|대규모|

🟢 **우수** | 🟡 **중간** | 🔴 **부족**

---
### 🎯 **Kafka를 통한 비동기 처리**

#### ✅ **이유:**
1. **완전한 비동기 처리:** Spring Boot와 Python 엔진 간의 강한 결합도 제거
2. **높은 확장성:** Python 엔진을 여러 개로 확장 가능
3. **실시간 데이터 처리:** 병목 현상 최소화

#### ✅ **적합한 사용 사례:**
- **실시간 처리 요구가 높은 시스템**
- **다수의 Python 엔진이 동시에 처리해야 하는 경우**
- **초대규모 데이터 및 트래픽**

#### ✅ **고려사항:**
- Kafka 인프라를 운영할 수 있는 경험과 리소스가 필요
---
### ✅ **2.2 시스템 역할 분리**

| **모듈**          | **책임**              | **기술 스택**      |
| --------------- | ------------------- | -------------- |
| **Spring Boot** | 사용자 요청 처리, 메타데이터 저장 | Kafka, DB, API |
| **Kafka**       | 데이터 중계 및 버퍼링        | Kafka Broker   |
| **Python 엔진**   | 프레임 분할 및 비식별화       | OpenCV, Kafka  |
| **스토리지**        | 프레임 및 비식별화된 데이터 저장  | S3, MinIO      |

---
## 🤔 **3. Kafka 유지보수성 문제**

Kafka 아키텍처의 단점은 다음과 같아:

1. **인프라 복잡성:** Kafka 브로커, ZooKeeper, 토픽 관리가 필요함.
2. **메시지 관리 어려움:** 토픽을 관리하고 메시지를 모니터링해야 함.
3. **장애 복구:** Kafka 자체에 장애가 발생하면 서비스 전체가 영향을 받을 수 있음.
4. **운영 비용:** Kafka 클러스터를 운영하기 위한 추가적인 하드웨어 및 리소스 필요.
---
## 🛡️ **4. Kafka 유지보수성 개선 전략**

### ✅ **4.1 Kafka 운영 도구 활용**
- **Confluent Control Center:** Kafka 클러스터 모니터링 및 관리.
- **Grafana + Prometheus:** Kafka 메트릭 실시간 모니터링.
- **Kafka Manager:** 토픽, 브로커 상태 시각화 및 관리.

### ✅ **4.2 메시지 모니터링 및 에러 핸들링**
- **Dead Letter Queue (DLQ):** 실패한 메시지는 별도의 토픽으로 전달하여 재처리.
- **Retry Mechanism:** 실패한 메시지를 재시도하는 메커니즘 구현.

### ✅ **4.3 클라우드 관리형 Kafka 서비스 사용**
- **AWS Managed Streaming for Kafka (MSK)**
- **Confluent Cloud**

### ✅ **4.4 표준화된 메시지 포맷 사용**
- 메시지는 JSON 대신 **Avro, Protobuf** 같은 Schema를 사용하여 데이터 일관성 유지.
---
## 🥇 **5. 최종 결론: Kafka를 선택해야 하는 이유**
1. **고성능 및 확장성:** Python 엔진과 Spring Boot를 독립적으로 확장 가능.
2. **실시간 처리:** Kafka의 스트리밍 특성으로 실시간 처리 가능.
3. **안정성:** 데이터 손실 없이 안정적으로 전달 가능.
4. **유연한 데이터 흐름:** 영상 처리 요청과 응답을 토픽으로 분리해 관리 가능.
---
**6. 추천 개선 사항**
1. **초기 도입:** Kafka를 도입하되, 먼저 작은 규모로 테스트 환경을 구성.
2. **메시지 모니터링 강화:** Dead Letter Queue 및 Retry Mechanism 적용.
3. **운영 도구 활용:** Kafka Manager, Grafana로 모니터링 강화.
4. **클라우드 Kafka 도입 고려:** AWS MSK나 Confluent Cloud로 운영 부담 최소화.
---