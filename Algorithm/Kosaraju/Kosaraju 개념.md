## 1. 원본 그래프

![[Pasted image 20250202044615.png]]


`brute force`로 모든 경우에 대해 탐색하고 찾는 것은 매우 비효율적이다.
`kosaraju` 알고리즘은 이런 것을 좀 더 효율적으로 찾을 수 있게 해준다.

아래 그림처럼 간선의 방향을 뒤집어보자.
![[Pasted image 20250202045153.png]]

뒤집힌 그래프에서 탐색을 한다는 것은 어떤 정점으로 '올 수 있는' 정점들을 모두 찾는다는 의미가 된다. 

여기서 ___'올 수 있는' 정점___ 과 ___'갈 수 있는' 정점___ 이 모두 존재하는 경우를 `강연결요소`라고 한다. 


0번에서 갈 수 있는 정점들의 집합과 0번으로 올 수 있는 정점들의 집합이 있을 때 둘의 교집합을 찾으면 0번 정점이 포함된 강연결요소들을 찾을 수 있습니다.

## 2. 브루트포스 방식과 다른점
브루트포스 방식은 **각 정점마다 DFS를 두 번 수행**해야 해서 **O(N * (N + M))** 의 복잡도를 가질 수 있다.  
하지만 **코사라주 알고리즘은 정방향 DFS + 역방6향 DFS를 한 번씩만 수행**해서 **O(N + M)** 으로 훨씬 효율적이다. 어렵게 써놨지만 간단히 말하면, 브루트포스 방식은 2중 반복문을 사용하는데 코사라주는 1중 반복문으로 갔다 오면 끝이다. 그래서 더 효율적이라는 소리다.

1. **DFS 종료 순서를 활용**
    
    - SCC를 찾을 때 **정방향 DFS에서 "가장 늦게 끝난 노드"부터 다시 DFS를 수행하면 SCC가 자연스럽게 분리됨.**
    - 브루트포스는 모든 정점에서 다 해봐야 하지만, 코사라주는 **필요한 정점만 역방향 DFS 수행**.
2. **한 번 방문한 정점은 다시 탐색하지 않음**
    
    - SCC에 포함된 정점은 한 번 찾으면 더 이상 탐색할 필요 없음.
    - 반면, 브루트포스는 모든 정점에서 다시 DFS를 돌려야 하므로 비효율적.

---

## 3. 코사라주를 활용할 때 위상 정렬이 필요한 이유

강한 연결 요소(SCC)를 찾으면, 그래프를 **DAG(유향 비순환 그래프)**로 변환할 수 있어.  
➡ **이 DAG를 정렬하면 위상 정렬이 됨.**

### 🔹 **왜 DAG(위상 정렬)으로 변환할까?**

- SCC 안에서는 모든 노드가 서로 도달 가능 → **하나의 노드처럼 취급 가능!**
- SCC끼리는 서로 연결될 수도 있지만, **DAG 형태로 정리하면 순환이 없어지고 문제를 풀기 쉬워짐**.
- 즉, **DAG에서 위상 정렬을 수행하면 SCC 간의 관계를 계층적으로 분석할 수 있음.**


---

[컴퓨터 과학](https://ko.wikipedia.org/wiki/%EC%BB%B4%ED%93%A8%ED%84%B0_%EA%B3%BC%ED%95%99 "컴퓨터 과학")에서 **코사라주 알고리즘** (**코사라주-샤리르 알고리즘**으로도 알려져 있다.)은 [유향그래프](https://ko.wikipedia.org/wiki/%EC%9C%A0%ED%96%A5%EA%B7%B8%EB%9E%98%ED%94%84 "유향그래프")에서의 [강한 연결 요소](https://ko.wikipedia.org/wiki/%EA%B0%95%ED%95%9C_%EC%97%B0%EA%B2%B0_%EC%9A%94%EC%86%8C "강한 연결 요소")를 [선형 시간](https://ko.wikipedia.org/wiki/%EC%8B%9C%EA%B0%84_%EB%B3%B5%EC%9E%A1%EB%8F%84 "시간 복잡도")에 찾는 [알고리즘](https://ko.wikipedia.org/wiki/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98 "알고리즘")이다. [앨프리드 에이호](https://ko.wikipedia.org/wiki/%EC%95%A8%ED%94%84%EB%A6%AC%EB%93%9C_%EC%97%90%EC%9D%B4%ED%98%B8 "앨프리드 에이호"), [존 홉크로프트](https://ko.wikipedia.org/wiki/%EC%A1%B4_%ED%99%89%ED%81%AC%EB%A1%9C%ED%94%84%ED%8A%B8 "존 홉크로프트") 및 [제프리 울만](https://ko.wikipedia.org/wiki/%EC%A0%9C%ED%94%84%EB%A6%AC_%EC%9A%B8%EB%A7%8C "제프리 울만")은 이 알고리즘을 [삼바시바 코사라주](https://ko.wikipedia.org/wiki/%EC%82%BC%EB%B0%94%EC%8B%9C%EB%B0%94_%EC%BD%94%EC%82%AC%EB%9D%BC%EC%A3%BC "삼바시바 코사라주") 및 [미샤 샤리르](https://ko.wikipedia.org/wiki/Micha_Sharir "Micha Sharir")의 것으로 보증한다. [삼바시바 코사라주](https://ko.wikipedia.org/wiki/S._Rao_Kosaraju "S. Rao Kosaraju")는 1978년에 이 알고리즘을 제안하였지만 출판하지 않았고, 1981년 [미샤 샤리르](https://ko.wikipedia.org/wiki/Micha_Sharir "Micha Sharir")는 독자적으로 알고리즘을 발견하고 출판하였다. 이 알고리즘은 [역방향 그래프](https://ko.wikipedia.org/wiki/Transpose_graph "Transpose graph")(모든 간선들의 방향을 뒤집은 그래프)가 원래 그래프와 정확히 같은 강한 연결 요소를 갖는다는 사실을 이용한다.

## 알고리즘

코사라주 알고리즘은 크게 네 가지의 그래프 연산을 바탕으로 한다.

- 그래프의 정점들을 열거하는 연산
- 정점마다 데이터를 저장하는 연산(그래프의 자료 구조 안에 저장하는 방법 뿐만 아니라 정점들을 인덱스로 하는 배열에 저장하는 방법도 있다.)
- 정점에서 나가는 방향의 이웃(순방향 이웃) 정점들을 열거하는 연산(순방향 탐색)
- 정점에서 들어오는 방향의 이웃(역방향 이웃) 정점들을 열거하는 연산(역방향 탐색)

마지막 연산에서 원본 그래프를 역방향 그래프로 표현하는 것은 순방향 순회를 할 때 비용 없이 가능하다. 이 알고리즘에 필요한 유일한 자료 구조는 그래프 정점들의 순서가 매겨진 목록 _L_ 이다. 이 목록은 각 정점을 한번씩 포함하게 된다.

만약 그래프의 강한 연결 요소들을 각 구성 요소에 대해 별도의 루트 정점을 지정하고 각 정점에 구성 요소의 루트 정점을 할당함으로써 표현할 경우 코사라주의 알고리즘은 다음과 같이 적용될 수 있다.

1. 그래프의 각 정점 _u_ 에 대하여, _u_ 를 방문되지 않은 것으로 표시한다. 이때, 목록 _L_ 은 비어 있다.
2. 그래프의 각 정점 _u_ 에 대하여 정점을 방문하는 함수인 Visit(_u_)를 수행하고, Visit(_u_)는 재귀적으로 서브루틴을 작동시킨다.
    
    만약 _u_ 가 방문되지 않았다면:
    
    1. _u_ 를 방문한 것으로 표시한다.
    2. _u_ 의 바깥쪽 이웃 _v_ 에 대해 Visit(_v_)를 수행한다.
    3. _L_ 앞에 _u_ 를 추가한다.
    
    그렇지 않으면:
    
          아무것도 하지 않는다
    
3. _L_ 에 순서에 따라 각 원소 u에 대하여 강한 연결 요소에 할당시키는 함수인 Assign(_u_,_u_) Assign(_u_,_**루트**_)는 재귀적으로 서브루틴을 작동시킨다.
    
    만약 _u_ 가 할당되지 않은 요소라면:
    
    1. 루트가 _**루트**_인 강한 연결 요소에 u를 포함시킨다.
    2. _u_ 의 안쪽 이웃 _v_ 에 대해 Assign(_v_,_루트_)를 수행한다.
    
    그렇지 않으면:
    
          아무것도 하지 않는다
    

각 정점에 강한 연결 요소의 번호를 할당하거나 강한 연결 요소 별로 포함하고 있는 정점의 리스트를 만드는 등의 사소한 변형이 가능하다. 방문하지 않음/방문함 표시의 저장 장소는 정점마다 루트를 최종적으로 할당할 때 공유될 수 있다.

이 알고리즘의 중요한 부분은 그래프 간선의 첫번째(순방향) 순회 때, 정점들이 트리가 탐색되는 순서와 같이 후위 순서의 관계로 검색트리 목록 _L_ 에 추가된다는 것이다. 이것은 정점 _v_ 가 처음 방문되었는지와 무관하다. 왜냐하면 정점 _v_ 가 방문되는 경우는 모든 정점들이 나열된 _L_에서 나타나거나, 방문된 다른 정점 _u_가 _v_의 바깥 이웃이여서 나타나기 때문이다. _L_ 에 _v_ 가 _u_ 보다 앞에 추가되었다는 것은 어느쪽으로든 간에 u에서 v로의 순방향 경로가 존재한다면 최종 리스트 _L_ 에는 _u_ 가 _v_ 보다 앞에 나타나기 때문이다.(만약 _u_ 와 _v_ 모두 같은 강한 연결 요소에 포함되지 않는다면, _L_에서 그들의 상대적 순서는 임의적이다. 간결함을 위해 [깊이 우선 탐색](https://ko.wikipedia.org/wiki/%EA%B9%8A%EC%9D%B4_%EC%9A%B0%EC%84%A0_%ED%83%90%EC%83%89 "깊이 우선 탐색")을 채용한 알고리즘이 위에 기술되어있지만, 후위 순회의 특성이 보존되는 경우 [너비 우선 탐색](https://ko.wikipedia.org/wiki/%EB%84%88%EB%B9%84_%EC%9A%B0%EC%84%A0_%ED%83%90%EC%83%89 "너비 우선 탐색")에 대해서도 작동한다.

## 시간 복잡도

그래프가 [인접 리스트](https://ko.wikipedia.org/wiki/%EC%9D%B8%EC%A0%91_%EB%A6%AC%EC%8A%A4%ED%8A%B8 "인접 리스트")의 형태로 주어질 때, 코사라주의 알고리즘은 두 번의 그래프 순회가 수행되므로 최적의 경우 Θ ( V + E ) {\displaystyle \Theta (V+E)} ![{\displaystyle \Theta (V+E)}](https://wikimedia.org/api/rest_v1/media/math/render/svg/1d6f3cfdfc2dd5f269373778460f22af0c4d3466) (선형)시간에 수행된다. 왜냐하면 어떠한 알고리즘이라도 반드시 모든 정점과 간선을 시험해봐야 하기 때문이다. 이것은 개념적으로 가장 간단한 효율적인 알고리즘이지만 오직 한번의 순회만 시행하는 타잔의 강한 연결 요소 알고리즘이나 경로 기반 강한 요소 알고리즘에 비해 비효율적이다.

그래프가 [인접 행렬](https://ko.wikipedia.org/wiki/%EC%9D%B8%EC%A0%91%ED%96%89%EB%A0%AC "인접행렬")로 주어질 때 ,이 알고리즘은  O ( V 2 ) ![{\displaystyle O(V^{2})}](https://wikimedia.org/api/rest_v1/media/math/render/svg/11a5ce39ea34c896a32654d0b4afd06694e7376c) 시간에 작동된다.