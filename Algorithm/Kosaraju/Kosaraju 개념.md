## 1. 원본 그래프

![[Pasted image 20250202044615.png]]


`brute force`로 모든 경우에 대해 탐색하고 찾는 것은 매우 비효율적이다.
`kosaraju` 알고리즘은 이런 것을 좀 더 효율적으로 찾을 수 있게 해준다.

아래 그림처럼 간선의 방향을 뒤집어보자.
![[Pasted image 20250202045153.png]]

뒤집힌 그래프에서 탐색을 한다는 것은 어떤 정점으로 '올 수 있는' 정점들을 모두 찾는다는 의미가 된다. 

여기서 ___'올 수 있는' 정점___ 과 ___'갈 수 있는' 정점___ 이 모두 존재하는 경우를 `강연결요소`라고 한다. 


0번에서 갈 수 있는 정점들의 집합과 0번으로 올 수 있는 정점들의 집합이 있을 때 둘의 교집합을 찾으면 0번 정점이 포함된 강연결요소들을 찾을 수 있습니다.

## 2. 브루트포스 방식과 다른점
브루트포스 방식은 **각 정점마다 DFS를 두 번 수행**해야 해서 **O(N * (N + M))** 의 복잡도를 가질 수 있다.  
하지만 **코사라주 알고리즘은 정방향 DFS + 역방향 DFS를 한 번씩만 수행**해서 **O(N + M)** 으로 훨씬 효율적이다. 어렵게 써놨지만 간단히 말하면, 브루트포스 방식은 2중 반복문을 사용하는데 코사라주는 1중 반복문으로 갔다 오면 끝이다. 그래서 더 효율적이라는 소리다.

1. **DFS 종료 순서를 활용**
    
    - SCC를 찾을 때 **정방향 DFS에서 "가장 늦게 끝난 노드"부터 다시 DFS를 수행하면 SCC가 자연스럽게 분리됨.**
    - 브루트포스는 모든 정점에서 다 해봐야 하지만, 코사라주는 **필요한 정점만 역방향 DFS 수행**.
2. **한 번 방문한 정점은 다시 탐색하지 않음**
    
    - SCC에 포함된 정점은 한 번 찾으면 더 이상 탐색할 필요 없음.
    - 반면, 브루트포스는 모든 정점에서 다시 DFS를 돌려야 하므로 비효율적.

➡ **즉, 같은 원리지만 DFS를 훨씬 효율적으로 사용하는 방법이 코사라주 알고리즘이야!**