## 1. 원본 그래프

![[Pasted image 20250202044615.png]]


`brute force`로 모든 경우에 대해 탐색하고 찾는 것은 매우 비효율적이다.
`kosaraju` 알고리즘은 이런 것을 좀 더 효율적으로 찾을 수 있게 해준다.

아래 그림처럼 간선의 방향을 뒤집어보자.
![[Pasted image 20250202045153.png]]

뒤집힌 그래프에서 탐색을 한다는 것은 어떤 정점으로 '올 수 있는' 정점들을 모두 찾는다는 의미가 된다. 

여기서 ___'올 수 있는' 정점___ 과 ___'갈 수 있는' 정점___ 이 모두 존재하는 경우를 `강연결요소`라고 한다. 


0번에서 갈 수 있는 정점들의 집합과 0번으로 올 수 있는 정점들의 집합이 있을 때 둘의 교집합을 찾으면 0번 정점이 포함된 강연결요소들을 찾을 수 있습니다.

## 2. 브루트포스 방식과 다른점
브루트포스 방식은 **각 정점마다 DFS를 두 번 수행**해야 해서 **O(N * (N + M))** 의 복잡도를 가질 수 있다.  
하지만 **코사라주 알고리즘은 정방향 DFS + 역방향 DFS를 한 번씩만 수행**해서 **O(N + M)** 으로 훨씬 효율적이다. 어렵게 써놨지만 간단히 말하면, 브루트포스 방식은 2중 반복문을 사용하는데 코사라주는 1중 반복문으로 갔다 오면 끝이다. 그래서 더 효율적이라는 소리다.

1. **DFS 종료 순서를 활용**
    
    - SCC를 찾을 때 **정방향 DFS에서 "가장 늦게 끝난 노드"부터 다시 DFS를 수행하면 SCC가 자연스럽게 분리됨.**
    - 브루트포스는 모든 정점에서 다 해봐야 하지만, 코사라주는 **필요한 정점만 역방향 DFS 수행**.
2. **한 번 방문한 정점은 다시 탐색하지 않음**
    
    - SCC에 포함된 정점은 한 번 찾으면 더 이상 탐색할 필요 없음.
    - 반면, 브루트포스는 모든 정점에서 다시 DFS를 돌려야 하므로 비효율적.

---

## 3. 코사라주를 활용할 때 위상 정렬이 필요한 이유

강한 연결 요소(SCC)를 찾으면, 그래프를 **DAG(유향 비순환 그래프)**로 변환할 수 있어.  
➡ **이 DAG를 정렬하면 위상 정렬이 됨.**

### 🔹 **왜 DAG(위상 정렬)으로 변환할까?**

- SCC 안에서는 모든 노드가 서로 도달 가능 → **하나의 노드처럼 취급 가능!**
- SCC끼리는 서로 연결될 수도 있지만, **DAG 형태로 정리하면 순환이 없어지고 문제를 풀기 쉬워짐**.
- 즉, **DAG에서 위상 정렬을 수행하면 SCC 간의 관계를 계층적으로 분석할 수 있음.**
- 